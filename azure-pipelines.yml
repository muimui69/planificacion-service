trigger:
- main

resources:
- repo: self

variables:
  dockerRegistryServiceConnection: 'container-planificacion'
  imageRepository: 'servicio-planificacion'
  containerRegistry: 'containerplanificacion.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  vmImageName: 'ubuntu-latest'
  imageFullName: '$(containerRegistry)/$(imageRepository)'
  # variables para capturar códigos de salida de grype (inicializadas a 0)
  GRYPE_SOURCE_EXIT: '0'
  GRYPE_IMAGE_EXIT: '0'

stages:

- stage: Build
  displayName: Build, Scan & Push
  jobs:
  - job: Build
    pool:
      vmImage: $(vmImageName)
    steps:

    - checkout: self

    - task: Maven@3
      displayName: "Build Spring Boot JAR"
      inputs:
        mavenPomFile: "pom.xml"
        goals: "package"
        publishJUnitResults: false
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '1.17'
        mavenOptions: "-Xmx3072m"
        testResultsFiles: "**/surefire-reports/*.xml"
        mavenAuthenticateFeed: false
        effectivePomSkip: true

    - script: |
        echo "Installing Grype..."
        # Se necesita sudo para escribir en /usr/local/bin en ubuntu-latest
        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sudo sh -s -- -b /usr/local/bin
        grype --version
      displayName: "Install Grype"

    - script: |
        echo "Scanning project source (grype)..."
        set +e
        grype dir:.
        GRYPE_SOURCE_EXIT=$?
        echo "grype source exit code: $GRYPE_SOURCE_EXIT"
        # exportar variable al pipeline para usarla en condiciones
        echo "##vso[task.setvariable variable=GRYPE_SOURCE_EXIT]$GRYPE_SOURCE_EXIT"
        set -e
      displayName: "Grype Scan - Source"

    - task: Docker@2
      displayName: "Build Local Docker Image"
      inputs:
        command: build
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)

    # Asegurarse del tag completo localmente (por si Docker@2 no creó exactamente el tag con el registry)
    - script: |
        echo "Ensuring full image tag locally: $(imageFullName):$(tag)"
        docker images
        # tag local (silent si ya existe)
        if docker image inspect $(imageFullName):$(tag) >/dev/null 2>&1; then
          echo "Full-tag already exists"
        else
          docker tag $(imageRepository):$(tag) $(imageFullName):$(tag) || echo "Tag might already exist or build used full name"
        fi
        docker images | grep $(imageRepository) || true
      displayName: "Ensure image is tagged with registry host"

    - script: |
        echo "Scanning Docker image locally with grype: $(imageFullName):$(tag)"
        set +e
        grype $(imageFullName):$(tag)
        GRYPE_IMAGE_EXIT=$?
        echo "grype image exit code: $GRYPE_IMAGE_EXIT"
        echo "##vso[task.setvariable variable=GRYPE_IMAGE_EXIT]$GRYPE_IMAGE_EXIT"
        set -e
      displayName: "Grype Scan - Docker Image"

    - task: Docker@2
      displayName: "Push Image (only if both scans passed)"
      condition: and(succeeded(), eq(variables['GRYPE_SOURCE_EXIT'], '0'), eq(variables['GRYPE_IMAGE_EXIT'], '0'))
      inputs:
        command: push
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)